# TASK-002: Define Core Domain Models for Input Data

**Section**: 0. Project Scaffolding & Foundations
**Subsection**: 0.2
**Task ID**: TASK-002

## Description

Create Python data models (using Pydantic) that represent the input data structures for restaurants, locations, and menus. These models will be used throughout the site planner to consume data from the ingestion pipeline and transform it into website configurations.

The models must align closely with existing ingestion outputs to minimize mapping complexity. They should support validation, serialization, and provide a clean interface for the rest of the application.

**Reference Implementation**: 
- `menuhq/restaurant-finder/ingestion/src/schemas/bulk-discovery.ts` (TypeScript schemas)
- `menuhq/restaurant-finder/ingestion/src/schemas/extracted-menu.ts` (Menu structure)
- `menuhq/restaurant-finder/ingestion/data/restaurants/*/metadata.discovery.json` (Sample data)

## Current State

- Python package structure exists (from TASK-001)
- TypeScript schemas exist in `ingestion/src/schemas/` that define the data structures
- Sample JSON files exist in `ingestion/data/restaurants/` showing actual data format
- No Python models exist yet for this data
- Need to create models that can parse and validate JSON from ingestion pipeline

**Prerequisites**: TASK-001 must be completed

## Checklist

### Preparation and Setup

- [ ] Review TypeScript schemas in `ingestion/src/schemas/bulk-discovery.ts`
- [ ] Review menu schema in `ingestion/src/schemas/extracted-menu.ts`
- [ ] Examine sample JSON files in `ingestion/data/restaurants/` to understand actual data format
- [ ] Review Pydantic documentation for model definition patterns
- [ ] Decide on model organization (single file vs. multiple files)

### Implementation Steps

- [ ] Step 1: Set up models module structure
  - [ ] Create `src/restaurant_site_planner/models/` directory
  - [ ] Create `src/restaurant_site_planner/models/__init__.py`
  - [ ] Create `src/restaurant_site_planner/models/restaurant.py`
  - [ ] Create `src/restaurant_site_planner/models/menu.py`
  - [ ] Create `src/restaurant_site_planner/models/location.py`
- [ ] Step 2: Install Pydantic dependency
  - [ ] Add `pydantic>=2.0` to `pyproject.toml` dependencies
  - [ ] Run `pip install -e .` to install
- [ ] Step 3: Implement Restaurant model
  - [ ] Define `Restaurant` class with fields:
    - [ ] `name: str` (required)
    - [ ] `slug: str` (required)
    - [ ] `cuisine: Optional[str]` (primary cuisine)
    - [ ] `cuisines: Optional[List[str]]` (all cuisines/categories)
    - [ ] `city: str` (required)
    - [ ] `neighborhood: Optional[str]`
    - [ ] `state: Optional[str]`
    - [ ] `address: Optional[str]` (full street address)
    - [ ] `coordinates: Optional[Coordinates]` (lat/lon)
    - [ ] `phone: Optional[str]`
    - [ ] `phone_display: Optional[str]`
    - [ ] `email: Optional[str]`
    - [ ] `website: Optional[str]`
    - [ ] `hours: Optional[Dict[str, str]]` (day -> time range)
    - [ ] `price_range: Optional[str]` ("$", "$$", "$$$", "$$$$")
    - [ ] `rating: Optional[float]` (0-5)
    - [ ] `review_count: Optional[int]`
    - [ ] `photos: Optional[List[Photo]]`
    - [ ] `hero_image_url: Optional[str]`
    - [ ] `logo_url: Optional[str]`
    - [ ] `social_profiles: Optional[Dict[str, str]]` (facebook, instagram, tiktok)
    - [ ] `third_party_links: Optional[Dict[str, str]]` (doordash, ubereats, etc.)
  - [ ] Add Pydantic validators for:
    - [ ] Slug format validation (lowercase, alphanumeric, hyphens)
    - [ ] Rating range (0-5)
    - [ ] Phone format validation (optional)
    - [ ] URL validation for website, photos, social profiles
- [ ] Step 4: Implement Location model (for multi-location brands)
  - [ ] Define `Location` class with:
    - [ ] `id: Optional[str]` (location identifier)
    - [ ] `name: str` (location name, e.g. "Downtown Location")
    - [ ] `address: str` (required)
    - [ ] `city: str` (required)
    - [ ] `state: Optional[str]`
    - [ ] `coordinates: Optional[Coordinates]`
    - [ ] `phone: Optional[str]`
    - [ ] `hours: Optional[Dict[str, str]]`
    - [ ] `is_primary: bool` (default False)
  - [ ] Add validation for required fields
- [ ] Step 5: Implement Menu models
  - [ ] Define `Coordinates` helper class (lat/lon)
  - [ ] Define `Photo` helper class (url, source, width, height)
  - [ ] Define `MenuItem` class with:
    - [ ] `name: str` (required)
    - [ ] `description: Optional[str]`
    - [ ] `price: Optional[float]`
    - [ ] `price_display: Optional[str]` (e.g. "$12.99")
    - [ ] `images: Optional[List[str]]` (image URLs)
    - [ ] `modifiers: Optional[List[Modifier]]` (extras, sizes, etc.)
  - [ ] Define `MenuCategory` class with:
    - [ ] `name: str` (required)
    - [ ] `description: Optional[str]`
    - [ ] `items: List[MenuItem]` (required)
    - [ ] `order: Optional[int]` (display order)
  - [ ] Define `Menu` class with:
    - [ ] `name: str` (restaurant name)
    - [ ] `categories: List[MenuCategory]` (required)
    - [ ] `extracted_at: Optional[datetime]`
    - [ ] `metadata: Optional[Dict]`
- [ ] Step 6: Add model serialization/deserialization
  - [ ] Ensure all models can serialize to JSON via `.model_dump()`
  - [ ] Ensure all models can parse from JSON via `.model_validate()`
  - [ ] Add `.model_dump_json()` support for direct JSON string output

### Specific Requirements

- [ ] Requirement 1: Models match ingestion data structure
  - [ ] Can parse sample JSON files from `ingestion/data/restaurants/`
  - [ ] Handles optional fields gracefully (no errors on missing optional data)
  - [ ] Supports all fields present in TypeScript schemas
- [ ] Requirement 2: Models provide validation
  - [ ] Invalid data raises clear validation errors
  - [ ] Required fields are enforced
  - [ ] Type checking works (str vs int vs float)
- [ ] Requirement 3: Models are extensible
  - [ ] Easy to add new optional fields without breaking existing code
  - [ ] Supports forward compatibility (ignores unknown fields or warns)

### Error Handling and Edge Cases

- [ ] Handle error case 1: Missing required fields
  - [ ] Validation error message clearly identifies missing field
  - [ ] Error includes field path for nested structures
- [ ] Handle error case 2: Invalid data types
  - [ ] String provided where number expected
  - [ ] Number provided where string expected
  - [ ] Invalid enum values
- [ ] Handle edge case 1: Empty lists/arrays
  - [ ] Empty `categories` list in Menu
  - [ ] Empty `items` list in MenuCategory
  - [ ] Empty `photos` list in Restaurant
- [ ] Handle edge case 2: Null/None values
  - [ ] Optional fields can be None
  - [ ] JSON null maps to Python None correctly
- [ ] Handle edge case 3: Malformed JSON
  - [ ] JSON parsing errors are caught and re-raised with context

### Testing

- [ ] Write unit tests: `tests/test_models_restaurant.py`
  - [ ] Test parsing valid restaurant JSON
  - [ ] Test parsing restaurant with all optional fields
  - [ ] Test parsing restaurant with minimal required fields
  - [ ] Test validation errors for missing required fields
  - [ ] Test validation errors for invalid data types
  - [ ] Test slug format validation
  - [ ] Test rating range validation (0-5)
  - [ ] Test URL validation
- [ ] Write unit tests: `tests/test_models_menu.py`
  - [ ] Test parsing valid menu JSON
  - [ ] Test menu with multiple categories
  - [ ] Test menu with items that have modifiers
  - [ ] Test empty categories list
  - [ ] Test menu item price parsing
- [ ] Write unit tests: `tests/test_models_location.py`
  - [ ] Test parsing location data
  - [ ] Test multi-location scenarios
  - [ ] Test primary location flag
- [ ] Write integration tests: `tests/test_models_integration.py`
  - [ ] Test parsing actual sample JSON files from `ingestion/data/restaurants/`
  - [ ] Test round-trip: JSON -> Model -> JSON (data preservation)
- [ ] Run full test suite: `pytest`
- [ ] Verify test coverage: `pytest --cov=restaurant_site_planner.models`

### Documentation

- [ ] Add docstrings to all model classes
  - [ ] Class-level docstrings explaining purpose
  - [ ] Field-level docstrings for complex fields
- [ ] Document model usage in `README.md`
  - [ ] Example: parsing restaurant JSON
  - [ ] Example: creating models programmatically
  - [ ] Example: validation error handling
- [ ] Add type hints to all model fields (Pydantic handles this automatically)
- [ ] Document any deviations from TypeScript schemas and why

### Verification

- [ ] Verify models can parse sample data files
- [ ] Verify validation works correctly
- [ ] Verify serialization produces valid JSON
- [ ] Verify no regressions in test suite
- [ ] Verify code follows Python/Pydantic best practices

## Notes

- This task is part of Phase 3: Owner.com-Aligned Restaurant Sites
- **Execution Timing**: Must be completed after TASK-001, before TASK-003
- **Dependencies**: 
  - TASK-001: Python project skeleton must exist
- **Important Considerations**: 
  - Keep models aligned with TypeScript schemas to minimize mapping complexity
  - Use Pydantic v2 for modern Python support and better performance
  - Consider using `Field()` for complex validation and documentation
  - Models should be forward-compatible (ignore unknown fields or log warnings)
- **Task Independence**: Can be developed independently after TASK-001
- **Current State**: No Python models exist yet

## Related Tasks

- Previous: TASK-001 (Create Python project skeleton)
- Next: TASK-003 (Define output contract models)
- Dependencies:
  - TASK-001: Python package structure must exist
- Related:
  - TASK-003: Output models will consume these input models
  - TASK-015: RestaurantHomeConfig will use Restaurant and Menu models

## Definition of Done

### Task Type: CODE/FILE WRITING TASK

**User Stories**:
1. **As a developer**, I want to parse restaurant JSON data from the ingestion pipeline so I can work with structured data
2. **As a developer**, I want validation errors when data is malformed so I can catch issues early
3. **As a developer**, I want models that match the ingestion schema so I don't need complex mapping logic

**Automated Tests**:
- [ ] Unit tests exist for Restaurant model: `tests/test_models_restaurant.py`
- [ ] Unit tests exist for Menu models: `tests/test_models_menu.py`
- [ ] Unit tests exist for Location model: `tests/test_models_location.py`
- [ ] Integration tests parse real sample JSON files: `tests/test_models_integration.py`
- [ ] All tests pass: `pytest tests/test_models*.py` exits with code 0
- [ ] Test coverage for models is >= 90%: `pytest --cov=restaurant_site_planner.models --cov-report=term-missing`
- [ ] Tests validate parsing of realistic sample JSON payloads
- [ ] Tests validate error handling for missing required fields
- [ ] Tests validate error handling for invalid data types

**Code Quality**:
- [ ] All models use Pydantic BaseModel
- [ ] All required fields are marked as non-optional
- [ ] Validation logic is implemented for complex fields (slug, rating, URLs)
- [ ] Models can serialize to JSON: `.model_dump_json()`
- [ ] Models can parse from JSON: `.model_validate()`
- [ ] Code follows Python style guidelines (PEP 8)
- [ ] Type hints are present (Pydantic provides these automatically)

**Git & Version Control**:
- [ ] All new files are added to git: `git add .`
- [ ] Changes are committed with descriptive message: `git commit -m "TASK-002: Define core domain models for input data"`
- [ ] Code is pushed to origin: `git push origin <branch-name>`
- [ ] Commit message includes task ID: TASK-002

**Final Verification**:
- [ ] All checklist items are completed
- [ ] All tests pass
- [ ] Models can parse at least 3 different sample JSON files from ingestion data
- [ ] Code is committed and pushed
- [ ] Documentation explains how to use the models
- [ ] Another developer can import and use the models successfully
